<html>
<head>
<script type='text/javascript' src='linkedlist.js'></script>
<script type='text/javascript' src='binarytree.js'></script>
<script type='text/javascript' src='canv.js'></script>
<script type='text/javascript' src='astar.js'></script>
<script type='text/javascript'>
var n = 30;
var width = 2*n;
var height = n;

var c = new Canv(640,320);
c.canvas.style.border = "1px solid black";

var map;
var ticktime = 100;
var brushsize = 1;

var nodes;
var you;
var step;
var end;

var blockQueue = new LinkedList("BLOCK_QUEUE");
var unblockQueue = new LinkedList("UNBLOCK_QUEUE");
var shiftDown = false;
var shouldAddSize = false;
var shouldTick = true;
var shouldClear = false;
var vStyle = 0; var vStyleCount = 1;
var shouldAlterHeight = false;
var hStyle = 0; var hStyleCount = 2;

function doit()
{
  document.getElementById("stage_container").appendChild(c.canvas);

  nodes = constructGrid(width,height);
  you = nodes[0][0];
  end = nodes[0][0];
  
  tick();
};

var constructGrid = function(width, height)
{
  //Manhattan distance (cheap + good approximation)
  var calculateH = function(node, goalNode) { return Math.abs(goalNode.x-node.x)+Math.abs(goalNode.y-node.y); };

  var calculateGFromNodeToNode = function(nodeA, g, nodeB) { return g+1; };
  map = new AStarGraph("Test", calculateH, calculateGFromNodeToNode);
  
  var pos = [];
  var tmpNode;
  for(var i = 0; i < width; i++)
  {
    pos[i] = [];
    for(var j = 0; j < height; j++)
    {
      tmpNode = {"x":i,"y":j,"block":false};
      map.add(tmpNode,i+"_"+j);
      pos[i][j] = tmpNode;
    }
  }
  for(var i = 0; i < width; i++)
  {
    for(var j = 0; j < height; j++)
    {
      if(i-1 >= 0)
        map.connectNodeToNode(pos[i][j],pos[i-1][j]);
      if(i+1 < width)
        map.connectNodeToNode(pos[i][j],pos[i+1][j]);
      if(j-1 >= 0)
        map.connectNodeToNode(pos[i][j],pos[i][j-1]);
      if(j+1 < height)
        map.connectNodeToNode(pos[i][j],pos[i][j+1]);
    }
  }
  map.resetNodes();
  return pos;
};

var addToGrid = function(deltaWidth, deltaHeight)
{
  var tmpNode;
  for(var i = width; i < width+deltaWidth; i++)
  {
    nodes[i] = [];
    for(j = 0; j < height; j++)
    {
      tmpNode = {"x":i,"y":j,"block":false};
      map.add(tmpNode,i+"_"+j);
      nodes[i][j] = tmpNode;
    }
  }
  for(var i = 0; i < width; i++)
  {
    for(j = height; j < height+deltaHeight; j++)
    {
      tmpNode = {"x":i,"y":j,"block":false};
      map.add(tmpNode,i+"_"+j);
      nodes[i][j] = tmpNode;
    }
  }
  for(var i = width; i < width+deltaWidth; i++)
  {
    for(var j = height; j < height+deltaHeight; j++)
    {
      tmpNode = {"x":i,"y":j,"block":false};
      map.add(tmpNode,i+"_"+j);
      nodes[i][j] = tmpNode;
    }
  }

  for(var i = 0; i < width; i++)
    map.connectNodeToNode(nodes[i][n-1],nodes[i][n]);
  for(var j = 0; j < height; j++)
    map.connectNodeToNode(nodes[n-1][j],nodes[n][j]);
  for(var i = 0; i < width; i++)
  {
    for(j = height; j < height+deltaHeight; j++)
    {
      if(i-1 >= 0 && !nodes[i-1][j].block)
        map.connectNodeToNode(nodes[i][j],nodes[i-1][j]);
      if(i+1 < width+deltaWidth && !nodes[i+1][j].block)
        map.connectNodeToNode(nodes[i][j],nodes[i+1][j]);
      if(j-1 >= 0 && !nodes[i][j-1].block)
        map.connectNodeToNode(nodes[i][j],nodes[i][j-1]);
      if(j+1 < height+deltaHeight && !nodes[i][j+1].block)
        map.connectNodeToNode(nodes[i][j],nodes[i][j+1]);
    }
  }
  for(var i = width; i < width+deltaWidth; i++)
  {
    for(j = 0; j < height; j++)
    {
      if(i-1 >= 0 && !nodes[i-1][j].block)
        map.connectNodeToNode(nodes[i][j],nodes[i-1][j]);
      if(i+1 < height+deltaWidth && !nodes[i+1][j].block)
        map.connectNodeToNode(nodes[i][j],nodes[i+1][j]);
      if(j-1 >= 0 && !nodes[i][j-1].block)
        map.connectNodeToNode(nodes[i][j],nodes[i][j-1]);
      if(j+1 < height+deltaHeight && !nodes[i][j+1].block)
        map.connectNodeToNode(nodes[i][j],nodes[i][j+1]);
    }
  }
  for(var i = width; i < width+deltaWidth; i++)
  {
    for(var j = height; j < height+deltaHeight; j++)
    {
      if(i-1 >= 0 && !nodes[i-1][j].block)
        map.connectNodeToNode(nodes[i][j],nodes[i-1][j]);
      if(i+1 < width+deltaWidth && !nodes[i+1][j].block)
        map.connectNodeToNode(nodes[i][j],nodes[i+1][j]);
      if(j-1 >= 0 && !nodes[i][j-1].block)
        map.connectNodeToNode(nodes[i][j],nodes[i][j-1]);
      if(j+1 < height+deltaHeight && !nodes[i][j+1].block)
        map.connectNodeToNode(nodes[i][j],nodes[i][j+1]);
    }
  }

  width += deltaWidth;
  height += deltaHeight;
  map.resetNodes();
};

function tick()
{
  dequeueBlocks();
  dequeueUnblocks();
  if(shouldAddSize) addToGrid(2,1);
  shouldAddSize = false;
  if(shouldClear)
  {
      for(var i = 0; i < width; i++)
        for(var j = 0; j < height; j++)
          unblockNode(i,j);
  }
  shouldClear = false;
  shouldAlterHeight = false;
  while(you == end) setRandomEnd();
  step = map.getBestStep(you,end);
  draw();
  if(shouldTick && step) you = step;
  setTimeout(tick, ticktime);
};

function draw()
{
  switch(vStyle)
  {
    case 0: //draw openness
      for(var i = 0; i < width; i++)
      {
        for(var j = 0; j < height; j++)
        {
          var r = 0; 
          var g = 0;
          var b = 0;
          
          //COLOR
          if(nodes[i][j] == end)     { r = 255; g = 0;   b = 0;   }
          else if(nodes[i][j] == you){ r = 0;   g = 255; b = 0;   }
          else if(nodes[i][j].block) { r = 255; g = 255; b = 255; }
          else if(nodes[i][j].ASTAR_STATE_ispath) b = 255;
          else if(nodes[i][j].ASTAR_STATE_closed || nodes[i][j].ASTAR_STATE_opened) { r = Math.floor(255*(nodes[i][j].ASTAR_STATE_g_ness/(height*(1+hStyle*19)))); g = 200; }
          c.context.fillStyle = "rgba("+r+","+g+","+b+",1)";
          c.context.fillRect((i/width)*c.canvas.width,(j/height)*c.canvas.height,(1/width)*c.canvas.width,(1/height)*c.canvas.height);
        }
      }
      break;
    case 1: //draw g-ness
      break;
  }
};

function setRandomEnd()
{
  rx = Math.floor(Math.random()*width);
  ry = Math.floor(Math.random()*height);
  while(nodes[rx][ry].block == true)
  {
    rx = Math.floor(Math.random()*width);
    ry = Math.floor(Math.random()*height);
  }

  end = nodes[rx][ry];
};

// WALL INPUT HANDLING

function addToBlockQueue(e)
{
  blockQueue.add({"x":e.clientX-c.canvas.offsetLeft,"y":e.clientY-c.canvas.offsetTop});
};

function addToUnblockQueue(e)
{
  unblockQueue.add({"x":e.clientX-c.canvas.offsetLeft,"y":e.clientY-c.canvas.offsetTop});
};

function recordClicks(e)
{
  if(!shiftDown)
  {
    window.addEventListener('mousemove', addToBlockQueue, false);
    addToBlockQueue(e);
  }
  else if(shiftDown)
  {
    window.addEventListener('mousemove', addToUnblockQueue, false);
    addToUnblockQueue(e);
    e.stopPropagation();
  }
};

function stopRecordingClicks(e)
{
  if(!shiftDown)
    window.removeEventListener('mousemove', addToBlockQueue, false);
  else if(shiftDown)
  {
    window.removeEventListener('mousemove', addToUnblockQueue, false);
    e.stopPropagation();
  }
};

function blockNode(x,y)
{
  if(!(x >= 0 && x < width && y >= 0 && y < height && 
    nodes[x][y] != you && nodes[x][y] != end &&
    !nodes[x][y].block)) return;
  if(x-1 >= 0)
    map.disconnectNodeToNode(nodes[x-1][y],nodes[x][y]);
  if(x+1 < width)
    map.disconnectNodeToNode(nodes[x+1][y],nodes[x][y]);
  if(y-1 >= 0)
    map.disconnectNodeToNode(nodes[x][y-1],nodes[x][y]);
  if(y+1 < height)
    map.disconnectNodeToNode(nodes[x][y+1],nodes[x][y]);
  nodes[x][y].block = true;
};

function dequeueBlocks()
{
  var pt;
  while(pt = blockQueue.firstMember())
  {
    var x = Math.floor((pt.x/c.canvas.width)*width);
    var y = Math.floor((pt.y/c.canvas.height)*height);
    blockNode(x,y);
    if(brushsize > 1)
    {
      blockNode(x-1,y);
      blockNode(x,y-1);
      blockNode(x-1,y-1);
    }
    blockQueue.remove(pt);
  }
};

function unblockNode(x,y)
{
  if(!(x >= 0 && x < width && y >= 0 && y < height && 
    nodes[x][y] != you && nodes[x][y] != end &&
    nodes[x][y].block)) return;
  if(x-1 >= 0)
    map.connectNodeToNode(nodes[x-1][y],nodes[x][y]);
  if(x+1 < width)
    map.connectNodeToNode(nodes[x+1][y],nodes[x][y]);
  if(y-1 >= 0)
    map.connectNodeToNode(nodes[x][y-1],nodes[x][y]);
  if(y+1 < height)
    map.connectNodeToNode(nodes[x][y+1],nodes[x][y]);
  nodes[x][y].block = false;
};

function dequeueUnblocks()
{
  var pt;
  while(pt = unblockQueue.firstMember())
  {
    var x = Math.floor((pt.x/c.canvas.width)*width);
    var y = Math.floor((pt.y/c.canvas.height)*height);
    unblockNode(x,y);
    if(brushsize > 1)
    {
      unblockNode(x-1,y);
      unblockNode(x,y-1);
      unblockNode(x-1,y-1);
    }
    unblockQueue.remove(pt);
  }
};
  
function downKey(e)
{
  switch(e.keyCode)
  {
    case 16: //shift
      shiftDown = true;
      break;
    case 32: //space
      shouldTick = !shouldTick;
      break;
    case 72: //h
      hStyle = (hStyle+1)%hStyleCount;
      shouldAlterHeight = true;
      break;
    case 86: //v
      vStyle = (vStyle+1)%vStyleCount;
      break;
    case 73: //i
      shouldAddSize = true;
      break;
    case 66: //b
      if(brushsize == 1) brushsize = 2;
      else if(brushsize == 2) brushsize = 1;
      break;
    case 67: //c
      shouldClear = true;
      break;
  };
};

function upKey(e)
{
  if(e.keyCode == 16) shiftDown = false;
};

document.addEventListener('mousedown', recordClicks, false);
document.addEventListener('mouseup', stopRecordingClicks, false);
document.addEventListener('keydown', downKey, false);
document.addEventListener('keyup', upKey, false);

window.addEventListener('load',doit,false);
</script>
</head>
<body style="height:100%; overflow:hidden;"> <!-- Stops scrolling -->
  <div id='stage_container' style="display:block; margin:50px auto; height:320px; width:640px;"  ></div>
  </div>
</body>
</html>
